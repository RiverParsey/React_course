<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>React course</title>
</head>
<body>
  
  <h2>Императивный и декларативный подход</h2>
  <p>
    Императивный подход (как): Я вижу, что тот угловой столик свободен. Мы пойдём туда и сядем там. <br>
    Декларативный подход (что): Столик для двоих, пожалуйста. <br><br>
    Напишите функцию, называющуюся double, которая принимает массив чисел и возвращает новый массив, каждый элемент которого в два раза больше входного: double([1,2,3]) -> [2,4,6]. <br>
    Напишите функцию, называющуюся add, которая принимает массив и возвращает сумму всех его элементов: add([1,2,3]) -> 6. <br>
    Используя jQuery (или чистый JavaScript), добавьте обработчик события click к элементу с id, равным btn. По нажатию переключите класс highlight и смените текст на Add Highlight или Remove Highlight, в зависимости от текущего состояния элемента. <br><br>
    <h3>Давайте взглянем на самые распространённые подходы к решению этих задач, которые являются императивными.</h3>
    <pre><code>
      function double (arr) {
        let results = []
        for (let i = 0; i < arr.length; i++){
          results.push(arr[i] * 2)
        }
        return results
      }

      function add (arr) {
        let result = 0
        for (let i = 0; i < arr.length; i++){
          result += arr[i]
        }
        return result
      }

      $("#btn").click(function() {
        $(this).toggleClass("highlight")
        $(this).text() === 'Add Highlight'
          ? $(this).text('Remove Highlight')
          : $(this).text('Add Highlight')
      })
    </code></pre>
    <h3>А теперь взглянем на декларативные примеры. Их цель — решить все проблемы, описанные выше. Поэтому каждый пример должен описывать, что происходит, быть неизменяемым и читаемым.</h3>
    <pre><code>
      function double (arr) {
        return arr.map((item) => item * 2)
      }

      function add (arr) {
        return arr.reduce((prev, current) => prev + current, 0)
      }

      {this.state.buttonText}
    </code></pre>
    <h3>Гораздо лучше ?</h3>
    <br>
    Заметьте, что в первых двух примерах я использовал встроенные методы JavaScript, map и reduce. Как видите, декларативные решения вновь оказались абстракциями над императивными реализациями. Но нас не интересует, как реализованы эти методы. Мы также не изменяем состояния, да и читается этот код лучше. <br><br>
    Ну а третий? В нём я немного схитрил, использовав React — но обратите внимание, что все три императивные ошибки исправлены. React замечателен тем, что в нём вы можете создавать декларативные пользовательские интерфейсы. Смотря на компонент Btn, сразу понятно, как будет выглядеть интерфейс. Кроме того, состояния «живут» не в DOM, а в самом React-компоненте. <br><br>
    Ещё одним преимуществом является то, что декларативный код является контекстно-независимым. Это значит, что его можно использовать в любой программе без изменений.
  </p>

  <br><br>

  <p>
    <h2>Что такое DOM</h2>
    Перед тем, как мы начнем вникать в то, что из себя представляет DOM виртуальный, давайте немного поговорим о том, чем является DOM реальный. <br><br>
    DOM (аббревиатура от Document Object Model) — способ представления структурного документа с помощью объектов. Это кроссплатформенное и языко-независимое соглашение для представления и взаимодействия с данными в HTML, XML и т.д. <br><br>
    Веб-браузеры обрабатывают составляющие DOM, и мы можем взаимодействовать с ними, используя JavaScript и CSS. Мы можем работать с узлами документа, изменять их данные, удалять и вставлять новые узлы. В наши дни DOM API является практически кроссплатформенным и кроссбраузерным.
    Так в чем же проблема? 
    <br><br>
    <h3>Virtual DOM</h3>
    Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM. <br><br>
    При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.
  </p>
  
  <script src="script.js"></script>
</body>
</html>